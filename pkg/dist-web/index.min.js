function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _arrayWithHoles(e){if(Array.isArray(e))return e}function _iterableToArrayLimit(e,t){var n=[],r=!0,o=!1,a=void 0;try{for(var u,c=e[Symbol.iterator]();!(r=(u=c.next()).done)&&(n.push(u.value),!t||n.length!==t);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==c.return||c.return()}finally{if(o)throw a}}return n}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}const OUTSIDE_RUN=Symbol("outside_run");let currentRun=OUTSIDE_RUN;const hookStateMap=new(WeakMap||Map),reset=()=>{currentRun=OUTSIDE_RUN},createHookApi=e=>{const t=hookStateMap.get(currentRun.context);void 0===t[currentRun.hookStateIndex]&&(t[currentRun.hookStateIndex]={});const n=t[currentRun.hookStateIndex],r=currentRun.onStateChange;return{onCleanUp(e){n.cleanUp=e},beforeNextRun(e){n.beforeNextRun=e},afterCurrentRun(e){n.afterCurrentRun=e},getContext:()=>currentRun.context,getState:e=>(void 0===n.state&&(n.state=e),n.state),setState(t){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=n.state;n.state=t,!o&&r&&r(e,a,t)}}},createHook=(e,t)=>(function(){if(currentRun.context===OUTSIDE_RUN)throw new Error("Hook was called outside of run()!");currentRun.hookStateIndex++;const n=createHookApi(e);for(var r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];return t(...o,n)});function runLifeCycleCallback(e,t,n){let r=n;for(;r--;){const o=t[n-r-1];o[e]&&(o[e](),o[e]=void 0)}}const cleanUp=e=>{const t=hookStateMap.get(e);runLifeCycleCallback("cleanUp",t,t.length)},dispose=e=>{const t=hookStateMap.get(e);runLifeCycleCallback("cleanUp",t,t.length),hookStateMap.delete(e)},run=function(e){if("function"==typeof e&&(e={context:e,function:e}),!(e.context instanceof Object))throw new Error("Run was called without a valid object context!");(currentRun=e).hookStateIndex=-1;let t=!1;hookStateMap.has(currentRun.context)||(hookStateMap.set(currentRun.context,[]),t=!0);const n=hookStateMap.get(currentRun.context),r=n.length;runLifeCycleCallback("beforeNextRun",n,r);for(var o=arguments.length,a=new Array(o>1?o-1:0),u=1;u<o;u++)a[u-1]=arguments[u];const c=e.function(...a);return c instanceof Promise?c.then(e=>(runLifeCycleCallback("afterCurrentRun",n,t?n.length:r),reset(),e)):(runLifeCycleCallback("afterCurrentRun",n,t?n.length:r),reset(),c)},useReducer=createHook("useReducer",(e,t,n)=>{let r=n.getState,o=n.setState;const a=r(t);return[a,t=>{o(e(a,t))}]}),useState=createHook("useState",e=>{const t=_slicedToArray(useReducer((e,t)=>t.value,e),2),n=t[0],r=t[1];return[n,e=>r({type:"set_state",value:e})]}),useEffect=createHook("useEffect",function(e){var t;let n;(arguments.length<=1?0:arguments.length-1)>1&&(n=arguments.length<=1?void 0:arguments[1]);const r=(t=(arguments.length<=1?0:arguments.length-1)-1+1)<1||arguments.length<=t?void 0:arguments[t],o=r.getState,a=r.setState,u=r.onCleanUp,c=r.afterCurrentRun;let l=o({}),s=l.values,i=l.cleanUp,f=!1;if(s!==n&&s&&s.length>0){f=!0;let e=s.length;for(;e--;)if(n[e]!==s[e]){f=!1;break}s=n}f||(i&&i(),c(()=>{i=e(),a({values:n,cleanUp:i}),u(i?()=>{i()}:void 0)}))});export{createHook,cleanUp,dispose,run,useReducer,useState,useEffect};
//# sourceMappingURL=index.min.js.map