function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _arrayWithHoles(e){if(Array.isArray(e))return e}function _iterableToArrayLimit(e,t){var o=[],n=!0,r=!1,a=void 0;try{for(var u,c=e[Symbol.iterator]();!(n=(u=c.next()).done)&&(o.push(u.value),!t||o.length!==t);n=!0);}catch(e){r=!0,a=e}finally{try{n||null==c.return||c.return()}finally{if(r)throw a}}return o}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}const contextMap=new(WeakMap||Map);let currentContext;const createHookApi=(e,t)=>{const o=t.hookStates[t.hookStateIndex];return{onCleanUp(e){o.cleanUp=e},beforeNextRun(e){o.beforeNextRun=e},afterCurrentRun(e){o.afterCurrentRun=e},getContext:()=>currentContext,getValue:e=>(void 0===o.value&&(o.value=e),o.value),setValue(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=o.value;o.value=n,!r&&t.onValueChange&&t.onValueChange(e,n,a)}}},createHook=(e,t)=>(function(){if(void 0===currentContext)throw new Error("Hook was called outside of run()!");const o=contextMap.get(currentContext);o.hookStateIndex++,void 0===o.hookStates[o.hookStateIndex]&&(o.hookStates[o.hookStateIndex]={value:void 0},o.hookStates[o.hookStateIndex].hookApi=createHookApi(e,o));for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];return t(o.hookStates[o.hookStateIndex].hookApi,...r)});function runLifeCycleCallback(e,t){for(const o of t)o[e]&&(o[e](),o[e]=void 0)}const hookus=(e,t)=>{if(!(e instanceof Object))throw new Error("Context must be an object!");contextMap.set(e,{hookStates:[],hookStateIndex:-1,onValueChange:t})},cleanUp=e=>{runLifeCycleCallback("cleanUp",contextMap.get(e).hookStates)},dispose=e=>{const t=contextMap.get(e);runLifeCycleCallback("cleanUp",t.hookStates),t.hookStates.length=0,t.delete(e)},pocus=function(e,t){if(void 0!==currentContext)throw new Error("Tried to start a run before the end of the previous run!");if(!contextMap.has(e))throw new Error("Tried to start a run without a registered context!");currentContext=e;const o=contextMap.get(currentContext);o.hookStateIndex=-1,runLifeCycleCallback("beforeNextRun",o.hookStates);for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];const u=t(...r),c=e=>(runLifeCycleCallback("afterCurrentRun",o.hookStates),currentContext=void 0,e);return u instanceof Promise?u.then(c):c(u)},hookuspocus=(e,t)=>{let o=t.context,n=t.onValueChange;void 0===o&&(o=e),hookus(o,n);const r=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return pocus(o,e,...n)};return r.dispose=(()=>{dispose(o),o=void 0,e=void 0}),r.cleanUp=(()=>cleanUp(o)),r},useReducer=createHook("useReducer",(e,t,o)=>{let n=e.getValue,r=e.setValue;const a=n(o);return[a,e=>{r(t(a,e))}]}),useState=e=>{const t=_slicedToArray(useReducer((e,t)=>t.value,e),2),o=t[0],n=t[1];return[o,e=>n({type:"set_state",value:e})]},useEffect=createHook("useEffect",(e,t,o)=>{let n=e.getValue,r=e.setValue,a=e.onCleanUp,u=e.afterCurrentRun,c=n({}),l=c.values,s=c.cleanUp,i=!1;if(l!==o&&l&&l.length>0){i=!0;let e=l.length;for(;e--;)if(o[e]!==l[e]){i=!1;break}l=o}i||(s&&s(),u(()=>{"function"!=typeof(s=t())&&(s=void 0),r({values:o,cleanUp:s}),a(s?()=>{s()}:void 0)}))});export{createHook,hookus,cleanUp,dispose,pocus,hookuspocus,useReducer,useState,useEffect};
//# sourceMappingURL=index.min.js.map