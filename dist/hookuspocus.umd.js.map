{"version":3,"file":"hookuspocus.umd.js","sources":["../src/core.js","../src/use_effect.js","../src/use_reducer.js","../src/use_state.js"],"sourcesContent":["let index;\r\nlet hookData;\r\nlet dataMap = new (WeakMap || Map)();\r\nexport const on = (hook, cb) => {\r\n  dataMap.set(hook, cb);\r\n};\r\nexport const hookus = hookFunction => {\r\n  return function hook() {\r\n    const context = hookData[0];\r\n    index++;\r\n    const data =\r\n      hookData[index] || (hookData[index] = [{ context, hook: hookFunction }]);\r\n    return (dataMap.get(hook) || hookFunction).apply(\r\n      {},\r\n      data.concat(Array.from(arguments))\r\n    );\r\n  };\r\n};\r\nconst runLifeCycles = name => {\r\n  hookData.forEach(data => {\r\n    if (data[0] && data[0][name]) {\r\n      data[0][name]();\r\n      delete data[0][name];\r\n    }\r\n  });\r\n};\r\nexport const pocus = (func, arg1, arg2) => {\r\n  index = 0;\r\n  const context = typeof arg1 === \"boolean\" ? func : arg1 || func;\r\n  const cleanUp = arg1 === true || arg2;\r\n  dataMap.set(context, (hookData = dataMap.get(context) || [context]));\r\n  let result;\r\n  if (cleanUp === true) {\r\n    runLifeCycles(\"cleanUp\");\r\n    dataMap.delete(context);\r\n  } else {\r\n    runLifeCycles(\"before\");\r\n    result = func();\r\n    runLifeCycles(\"after\");\r\n  }\r\n  hookData = null;\r\n  return result;\r\n};\r\n","import { hookus } from \"./core\";\r\nexport const useEffect = hookus((data, effect, values) => {\r\n  if (\r\n    !data.v ||\r\n    (values &&\r\n      !(\r\n        values.length === data.v.length &&\r\n        values.every(value => ~data.v.indexOf(value))\r\n      ))\r\n  ) {\r\n    data.v = values;\r\n    if (data.cleanUp) {\r\n      data.cleanUp();\r\n    }\r\n    data.after = () => {\r\n      data.cleanUp = effect();\r\n    };\r\n  }\r\n});\r\n","import { hookus } from \"./core\";\r\n\r\nexport const useReducer = hookus((data, reducer, initialArg, init) => {\r\n  data.s = data.s !== undefined ? data.s : init ? init(initialArg) : initialArg;\r\n  return [\r\n    data.s,\r\n    action => {\r\n      data.s = reducer(data.s, action);\r\n      return data.s;\r\n    }\r\n  ];\r\n});\r\n","import { useReducer } from \"./use_reducer\";\r\n\r\nexport const useState = initialState => {\r\n  const [state, dispatch] = useReducer(\r\n    (_, action) => action.value,\r\n    initialState\r\n  );\r\n  return [\r\n    state,\r\n    newState =>\r\n      dispatch({\r\n        value: newState\r\n      })\r\n  ];\r\n};\r\n"],"names":["let","index","hookData","dataMap","WeakMap","Map","hookus","hookFunction","hook","data","get","apply","concat","Array","from","arguments","runLifeCycles","name","forEach","useEffect","effect","values","v","length","every","value","indexOf","cleanUp","after","useReducer","reducer","initialArg","init","s","undefined","action","func","arg1","arg2","result","context","set","delete","cb","initialState","_","newState","dispatch"],"mappings":"iLAAAA,IAAIC,EACAC,EACAC,EAAU,IAAKC,SAAWC,KAIjBC,WAASC,UACb,SAASC,QAGRC,EACJP,IAFFD,KAEsBC,EAASD,GAAS,CAAC,SAHzBC,EAAS,GAG2BM,KAAMD,YAClDJ,EAAQO,IAAIF,IAASD,GAAcI,MACzC,GACAF,EAAKG,OAAOC,MAAMC,KAAKC,eAIvBC,WAAgBC,GACpBf,EAASgB,iBAAQT,GACXA,EAAK,IAAMA,EAAK,GAAGQ,KACrBR,EAAK,GAAGQ,YACDR,EAAK,GAAGQ,OCrBRE,EAAYb,WAAQG,EAAMW,EAAQC,GAE1CZ,EAAKa,KACLD,GAEGA,EAAOE,SAAWd,EAAKa,EAAEC,QACzBF,EAAOG,eAAMC,UAAUhB,EAAKa,EAAEI,QAAQD,QAG1ChB,EAAKa,EAAID,EACLZ,EAAKkB,SACPlB,EAAKkB,UAEPlB,EAAKmB,iBACHnB,EAAKkB,QAAUP,QCbRS,EAAavB,WAAQG,EAAMqB,EAASC,EAAYC,UAC3DvB,EAAKwB,OAAeC,IAAXzB,EAAKwB,EAAkBxB,EAAKwB,EAAID,EAAOA,EAAKD,GAAcA,EAC5D,CACLtB,EAAKwB,WACLE,UACE1B,EAAKwB,EAAIH,EAAQrB,EAAKwB,EAAGE,GAClB1B,EAAKwB,kCFkBIG,EAAMC,EAAMC,GAChCrC,EAAQ,MAIJsC,EAHEC,EAA0B,kBAATH,EAAqBD,EAAOC,GAAQD,EACrDT,GAAmB,IAATU,GAAiBC,SACjCnC,EAAQsC,IAAID,EAAUtC,EAAWC,EAAQO,IAAI8B,IAAY,CAACA,KAE1C,IAAZb,GACFX,EAAc,WACdb,EAAQuC,OAAOF,KAEfxB,EAAc,UACduB,EAASH,IACTpB,EAAc,UAEhBd,EAAW,KACJqC,iBAtCU/B,EAAMmC,GACvBxC,EAAQsC,IAAIjC,EAAMmC,qDGFIC,SACIf,WACvBgB,EAAGV,UAAWA,EAAOV,OACtBmB,gBAEK,eAELE,UACEC,EAAS,CACPtB,MAAOqB"}