const t=Symbol("outside_run");let e=t;const n=new(WeakMap||Map),o=()=>{e=t},a=(o,a)=>(...r)=>{if(e.context===t)throw new Error("Hook was called outside of run()!");e.hookStateIndex++;const c=(t=>{const o=n.get(e.context);void 0===o[e.hookStateIndex]&&(o[e.hookStateIndex]={});const a=o[e.hookStateIndex],r=e.onStateChange;return{onCleanUp(t){a.cleanUp=t},beforeNextRun(t){a.beforeNextRun=t},afterCurrentRun(t){a.afterCurrentRun=t},getContext:()=>e.context,getState:t=>(void 0===a.state&&(a.state=t),a.state),setState(e,n=!1){let o=a.state;a.state=e,!n&&r&&r(t,o,e)}}})(o);return a(...r,c)};function r(t,e,n){let o=n;for(;o--;){const a=e[n-o-1];a[t]&&(a[t](),a[t]=void 0)}}const c=t=>{const e=n.get(t);r("cleanUp",e,e.length)},s=t=>{const e=n.get(t);r("cleanUp",e,e.length),n.delete(t)},u=(t,...a)=>{if("function"==typeof t&&(t={context:t,function:t}),!(t.context instanceof Object))throw new Error("Run was called without a valid object context!");(e=t).hookStateIndex=-1;let c=!1;n.has(e.context)||(n.set(e.context,[]),c=!0);const s=n.get(e.context),u=s.length;r("beforeNextRun",s,u);const l=t.function(...a);return l instanceof Promise?l.then(t=>(r("afterCurrentRun",s,c?s.length:u),o(),t)):(r("afterCurrentRun",s,c?s.length:u),o(),l)},l=a("useReducer",(t,e,{getState:n,setState:o})=>{const a=n(e);return[a,e=>{o(t(a,e))}]}),f=a("useState",t=>{const[e,n]=l((t,e)=>e.value,t);return[e,t=>n({type:"set_state",value:t})]}),h=a("useEffect",(t,...e)=>{let n;e.length>1&&(n=e[0]);const{getState:o,setState:a,onCleanUp:r,afterCurrentRun:c}=e[e.length-1];let{values:s,cleanUp:u}=o({}),l=!1;if(s!==n&&s&&s.length>0){l=!0;let t=s.length;for(;t--;)if(n[t]!==s[t]){l=!1;break}s=n}l||(u&&u(),c(()=>{u=t(),a({values:n,cleanUp:u}),r(u?()=>{u()}:void 0)}))});export{a as createHook,c as cleanUp,s as dispose,u as run,l as useReducer,f as useState,h as useEffect};
//# sourceMappingURL=hooked.min.mjs.map
