{"version":3,"file":"hookuspocus.mjs","sources":["../src/core.js","../src/use_effect.js","../src/use_reducer.js","../src/use_state.js"],"sourcesContent":["let index;\r\nlet hookData;\r\nlet dataMap = new (WeakMap || Map)();\r\nexport const on = (hook, cb) => {\r\n  dataMap.set(hook, cb);\r\n};\r\nexport const hookus = hookFunction => {\r\n  return function hook() {\r\n    const context = hookData[0];\r\n    index++;\r\n    const data =\r\n      hookData[index] || (hookData[index] = [{ context, hook: hookFunction }]);\r\n    return (dataMap.get(hook) || hookFunction).apply(\r\n      {},\r\n      data.concat(Array.from(arguments))\r\n    );\r\n  };\r\n};\r\nconst runLifeCycles = name => {\r\n  hookData.forEach(data => {\r\n    if (data[0] && data[0][name]) {\r\n      data[0][name]();\r\n      delete data[0][name];\r\n    }\r\n  });\r\n};\r\nexport const pocus = (func, arg1, arg2) => {\r\n  index = 0;\r\n  const context = typeof arg1 === \"boolean\" ? func : arg1 || func;\r\n  const cleanUp = arg1 === true || arg2;\r\n  dataMap.set(context, (hookData = dataMap.get(context) || [context]));\r\n  let result;\r\n  if (cleanUp === true) {\r\n    runLifeCycles(\"cleanUp\");\r\n    dataMap.delete(context);\r\n  } else {\r\n    runLifeCycles(\"before\");\r\n    result = func();\r\n    runLifeCycles(\"after\");\r\n  }\r\n  hookData = null;\r\n  return result;\r\n};\r\n","import { hookus } from \"./core\";\r\nexport const useEffect = hookus((data, effect, values) => {\r\n  if (\r\n    !data.v ||\r\n    (values &&\r\n      !(\r\n        values.length === data.v.length &&\r\n        values.every(value => ~data.v.indexOf(value))\r\n      ))\r\n  ) {\r\n    data.v = values;\r\n    if (data.cleanUp) {\r\n      data.cleanUp();\r\n    }\r\n    data.after = () => {\r\n      data.cleanUp = effect();\r\n    };\r\n  }\r\n});\r\n","import { hookus } from \"./core\";\r\n\r\nexport const useReducer = hookus((data, reducer, initialArg, init) => {\r\n  data.s = data.s !== undefined ? data.s : init ? init(initialArg) : initialArg;\r\n  return [\r\n    data.s,\r\n    action => {\r\n      data.s = reducer(data.s, action);\r\n      return data.s;\r\n    }\r\n  ];\r\n});\r\n","import { useReducer } from \"./use_reducer\";\r\n\r\nexport const useState = initialState => {\r\n  const [state, dispatch] = useReducer(\r\n    (_, action) => action.value,\r\n    initialState\r\n  );\r\n  return [\r\n    state,\r\n    newState =>\r\n      dispatch({\r\n        value: newState\r\n      })\r\n  ];\r\n};\r\n"],"names":["let","index","hookData","dataMap","WeakMap","Map","on","hook","cb","set","hookus","hookFunction","data","get","apply","concat","Array","from","arguments","runLifeCycles","name","forEach","pocus","func","arg1","arg2","result","context","cleanUp","delete","useEffect","effect","values","v","length","every","value","indexOf","after","useReducer","reducer","initialArg","init","s","undefined","action","useState","initialState","_","newState","dispatch"],"mappings":"AAAAA,IAAIC,EACAC,EACAC,EAAU,IAAKC,SAAWC,KACjBC,WAAMC,EAAMC,GACvBL,EAAQM,IAAIF,EAAMC,IAEPE,WAASC,UACb,SAASJ,QAGRK,EACJV,IAFFD,KAEsBC,EAASD,GAAS,CAAC,SAHzBC,EAAS,GAG2BK,KAAMI,YAClDR,EAAQU,IAAIN,IAASI,GAAcG,MACzC,GACAF,EAAKG,OAAOC,MAAMC,KAAKC,eAIvBC,WAAgBC,GACpBlB,EAASmB,iBAAQT,GACXA,EAAK,IAAMA,EAAK,GAAGQ,KACrBR,EAAK,GAAGQ,YACDR,EAAK,GAAGQ,OAIRE,WAASC,EAAMC,EAAMC,GAChCxB,EAAQ,MAIJyB,EAHEC,EAA0B,kBAATH,EAAqBD,EAAOC,GAAQD,EACrDK,GAAmB,IAATJ,GAAiBC,SACjCtB,EAAQM,IAAIkB,EAAUzB,EAAWC,EAAQU,IAAIc,IAAY,CAACA,KAE1C,IAAZC,GACFT,EAAc,WACdhB,EAAQ0B,OAAOF,KAEfR,EAAc,UACdO,EAASH,IACTJ,EAAc,UAEhBjB,EAAW,KACJwB,GCxCII,EAAYpB,WAAQE,EAAMmB,EAAQC,GAE1CpB,EAAKqB,KACLD,GAEGA,EAAOE,SAAWtB,EAAKqB,EAAEC,QACzBF,EAAOG,eAAMC,UAAUxB,EAAKqB,EAAEI,QAAQD,QAG1CxB,EAAKqB,EAAID,EACLpB,EAAKgB,SACPhB,EAAKgB,UAEPhB,EAAK0B,iBACH1B,EAAKgB,QAAUG,QCbRQ,EAAa7B,WAAQE,EAAM4B,EAASC,EAAYC,UAC3D9B,EAAK+B,OAAeC,IAAXhC,EAAK+B,EAAkB/B,EAAK+B,EAAID,EAAOA,EAAKD,GAAcA,EAC5D,CACL7B,EAAK+B,WACLE,UACEjC,EAAK+B,EAAIH,EAAQ5B,EAAK+B,EAAGE,GAClBjC,EAAK+B,MCNLG,WAAWC,SACIR,WACvBS,EAAGH,UAAWA,EAAOT,OACtBW,gBAEK,eAELE,UACEC,EAAS,CACPd,MAAOa"}