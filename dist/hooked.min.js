!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).funcyjs={})}(this,function(e){"use strict";const t=Symbol("outside_run");let n,o=t;const r=new(WeakMap||Map),a=()=>{o=t},s=(e,a)=>(...s)=>{if(o.context===t)throw new Error("Hook was called outside of run()!");n++;const u=(e=>{const t=r.get(o.context);void 0===t[n]&&(t[n]={});const a=t[n],s=o.onStateChange;return{onCleanUp(e){a.cleanUp=e},beforeNextRun(e){a.beforeNextRun=e},afterCurrentRun(e){a.afterCurrentRun=e},getApi:()=>o.api,getContext:()=>o.context,getState:e=>(void 0===a.state&&(a.state=e),a.state),setState(t,n=!1){let o=a.state;a.state=t,!n&&s&&s(e,o,t)}}})(e);return a(...s,u)};function u(e,t,n){let o=n;for(;o--;){const r=t[n-o-1];r[e]&&(r[e](),r[e]=void 0)}}const c=s("useReducer",(e,t,{getState:n,setState:o})=>{const r=n(t);return[r,t=>{o(e(r,t))}]}),f=s("useState",e=>{const[t,n]=c((e,t)=>t.value,e);return[t,e=>n({type:"set_state",value:e})]}),l=s("useEffect",(e,...t)=>{let n;t.length>1&&(n=t[0]);const{getState:o,setState:r,onCleanUp:a,afterCurrentRun:s}=t[t.length-1];let{values:u,cleanUp:c}=o({}),f=!1;if(u!==n&&u&&u.length>0){f=!0;let e=u.length;for(;e--;)if(n[e]!==u[e]){f=!1;break}u=n}f||(c&&c(),s(()=>{c=e(),r({values:n,cleanUp:c}),a(c?()=>{c()}:void 0)}))});e.createHook=s,e.run=((e,{context:s,api:c,onStateChange:f=(()=>{})}={})=>{if(s||(s=e),!(s instanceof Object))throw new Error("Run was called without a valid object context!");if(o!==t)throw new Error("Run was called before the end of the previous run!");o={context:s,api:c,onStateChange:f},n=-1;let l=!1;r.has(s)||(r.set(s,[]),l=!0);const i=r.get(o.context),d=i.length;u("beforeNextRun",i,d);const p=e();return p instanceof Promise?p.then(e=>(u("afterCurrentRun",i,l?i.length:d),a(),e)):(u("afterCurrentRun",i,l?i.length:d),a(),p)}),e.useReducer=c,e.useState=f,e.useEffect=l,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=hooked.min.js.map
